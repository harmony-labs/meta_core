//! Sync protocol layer definitions.
//!
//! The sync protocol uses a layered architecture where each layer
//! has different shipping and verification characteristics.

use super::ContentHash;
use serde::{Deserialize, Serialize};

/// The kind of sync layer.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum LayerKind {
    /// L0: Canonical data (commits, documents, metadata).
    /// Always shipped, source of truth.
    Canonical,
    
    /// L1: Embeddings (content-addressed vectors).
    /// Can be shipped or regenerated.
    Embedding,
    
    /// L2a: Index metadata (params, checksums).
    /// Small, always shipped with index.
    IndexMeta,
    
    /// L2b: Index data (HNSW graph structure).
    /// Can be shipped or rebuilt from embeddings.
    IndexData,
}

impl LayerKind {
    /// Whether this layer is always shipped (vs. optionally regenerated).
    pub fn is_canonical(&self) -> bool {
        matches!(self, LayerKind::Canonical)
    }

    /// Whether this layer can be regenerated from lower layers.
    pub fn is_derived(&self) -> bool {
        matches!(self, LayerKind::Embedding | LayerKind::IndexMeta | LayerKind::IndexData)
    }

    /// Get the layer number for ordering.
    pub fn level(&self) -> u8 {
        match self {
            LayerKind::Canonical => 0,
            LayerKind::Embedding => 1,
            LayerKind::IndexMeta => 2,
            LayerKind::IndexData => 2,
        }
    }
}

/// A sync layer with its content and metadata.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Layer {
    /// The kind of this layer.
    pub kind: LayerKind,
    
    /// Content hash for change detection.
    pub hash: String,
    
    /// Size in bytes.
    pub size: u64,
    
    /// Whether this layer was locally generated (vs. received).
    pub generated_locally: bool,
    
    /// Timestamp of last modification (Unix epoch seconds).
    pub modified_at: u64,
}

impl Layer {
    /// Create a new layer.
    pub fn new(kind: LayerKind, hash: ContentHash, size: u64) -> Self {
        Self {
            kind,
            hash: hash.to_hex(),
            size,
            generated_locally: true,
            modified_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .map(|d| d.as_secs())
                .unwrap_or(0),
        }
    }

    /// Check if this layer needs to be shipped (vs. regenerated by peer).
    pub fn should_ship(&self, peer_can_generate: bool) -> bool {
        match self.kind {
            LayerKind::Canonical => true,  // Always ship canonical data
            LayerKind::IndexMeta => true,  // Always ship metadata
            _ => !peer_can_generate,       // Ship if peer can't generate
        }
    }
}

/// A set of layers representing complete sync state.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LayerSet {
    /// L0: Canonical data.
    pub canonical: Option<Layer>,
    
    /// L1: Embeddings.
    pub embedding: Option<Layer>,
    
    /// L2a: Index metadata.
    pub index_meta: Option<Layer>,
    
    /// L2b: Index data.
    pub index_data: Option<Layer>,
}

impl LayerSet {
    /// Create a new empty layer set.
    pub fn new() -> Self {
        Self::default()
    }

    /// Add or update a layer.
    pub fn set_layer(&mut self, layer: Layer) {
        match layer.kind {
            LayerKind::Canonical => self.canonical = Some(layer),
            LayerKind::Embedding => self.embedding = Some(layer),
            LayerKind::IndexMeta => self.index_meta = Some(layer),
            LayerKind::IndexData => self.index_data = Some(layer),
        }
    }

    /// Get a layer by kind.
    pub fn get_layer(&self, kind: LayerKind) -> Option<&Layer> {
        match kind {
            LayerKind::Canonical => self.canonical.as_ref(),
            LayerKind::Embedding => self.embedding.as_ref(),
            LayerKind::IndexMeta => self.index_meta.as_ref(),
            LayerKind::IndexData => self.index_data.as_ref(),
        }
    }

    /// Check if a layer has changed compared to another set.
    pub fn layer_changed(&self, kind: LayerKind, other: &LayerSet) -> bool {
        match (self.get_layer(kind), other.get_layer(kind)) {
            (Some(a), Some(b)) => a.hash != b.hash,
            (Some(_), None) | (None, Some(_)) => true,
            (None, None) => false,
        }
    }

    /// Get total size of all layers.
    pub fn total_size(&self) -> u64 {
        [&self.canonical, &self.embedding, &self.index_meta, &self.index_data]
            .iter()
            .filter_map(|l| l.as_ref())
            .map(|l| l.size)
            .sum()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::sync::hash_content;

    #[test]
    fn test_layer_kind_levels() {
        assert_eq!(LayerKind::Canonical.level(), 0);
        assert_eq!(LayerKind::Embedding.level(), 1);
        assert_eq!(LayerKind::IndexMeta.level(), 2);
        assert_eq!(LayerKind::IndexData.level(), 2);
    }

    #[test]
    fn test_layer_kind_canonical() {
        assert!(LayerKind::Canonical.is_canonical());
        assert!(!LayerKind::Embedding.is_canonical());
    }

    #[test]
    fn test_layer_kind_derived() {
        assert!(!LayerKind::Canonical.is_derived());
        assert!(LayerKind::Embedding.is_derived());
        assert!(LayerKind::IndexData.is_derived());
    }

    #[test]
    fn test_layer_should_ship() {
        let hash = hash_content(b"test");
        let canonical = Layer::new(LayerKind::Canonical, hash.clone(), 100);
        let embedding = Layer::new(LayerKind::Embedding, hash.clone(), 200);

        // Canonical always ships
        assert!(canonical.should_ship(true));
        assert!(canonical.should_ship(false));

        // Embedding ships only if peer can't generate
        assert!(!embedding.should_ship(true));
        assert!(embedding.should_ship(false));
    }

    #[test]
    fn test_layer_set_operations() {
        let mut set = LayerSet::new();
        let hash = hash_content(b"test");
        
        let layer = Layer::new(LayerKind::Canonical, hash, 100);
        set.set_layer(layer);

        assert!(set.get_layer(LayerKind::Canonical).is_some());
        assert!(set.get_layer(LayerKind::Embedding).is_none());
        assert_eq!(set.total_size(), 100);
    }

    #[test]
    fn test_layer_changed_detection() {
        let mut set1 = LayerSet::new();
        let mut set2 = LayerSet::new();

        let hash1 = hash_content(b"content1");
        let hash2 = hash_content(b"content2");

        set1.set_layer(Layer::new(LayerKind::Canonical, hash1, 100));
        set2.set_layer(Layer::new(LayerKind::Canonical, hash2, 100));

        assert!(set1.layer_changed(LayerKind::Canonical, &set2));
        assert!(!set1.layer_changed(LayerKind::Embedding, &set2)); // Both None
    }
}
