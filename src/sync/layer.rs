//! Sync protocol layer definitions.
//!
//! The sync protocol uses a layered architecture where each layer
//! has different shipping and verification characteristics.

use super::ContentHash;
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

/// The kind of sync layer.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum LayerKind {
    /// L0: Canonical data (commits, documents, metadata).
    /// Always shipped, source of truth.
    Canonical,

    /// L1: Embeddings (content-addressed vectors).
    /// Can be shipped or regenerated.
    Embedding,

    /// L2a: Index metadata (params, checksums).
    /// Small, always shipped with index.
    IndexMeta,

    /// L2b: Index data (HNSW graph structure).
    /// Can be shipped or rebuilt from embeddings.
    IndexData,
}

impl LayerKind {
    /// All layer kinds in order.
    pub const ALL: [LayerKind; 4] = [
        LayerKind::Canonical,
        LayerKind::Embedding,
        LayerKind::IndexMeta,
        LayerKind::IndexData,
    ];

    /// Whether this layer is always shipped (vs. optionally regenerated).
    #[inline]
    pub const fn is_canonical(self) -> bool {
        matches!(self, LayerKind::Canonical)
    }

    /// Whether this layer can be regenerated from lower layers.
    #[inline]
    pub const fn is_derived(self) -> bool {
        matches!(
            self,
            LayerKind::Embedding | LayerKind::IndexMeta | LayerKind::IndexData
        )
    }

    /// Get the layer number for ordering.
    #[inline]
    pub const fn level(self) -> u8 {
        match self {
            LayerKind::Canonical => 0,
            LayerKind::Embedding => 1,
            LayerKind::IndexMeta | LayerKind::IndexData => 2,
        }
    }

    /// Get the parent layer (if any).
    #[inline]
    pub const fn parent(self) -> Option<LayerKind> {
        match self {
            LayerKind::Canonical => None,
            LayerKind::Embedding => Some(LayerKind::Canonical),
            LayerKind::IndexMeta | LayerKind::IndexData => Some(LayerKind::Embedding),
        }
    }
}

/// A sync layer with its content and metadata.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Layer {
    /// The kind of this layer.
    pub kind: LayerKind,

    /// Content hash for change detection.
    pub hash: ContentHash,

    /// Size in bytes.
    pub size: u64,

    /// Whether this layer was locally generated (vs. received from peer).
    #[serde(default)]
    pub generated_locally: bool,

    /// Timestamp of last modification (Unix epoch seconds).
    pub modified_at: u64,

    /// Optional parent hash for invalidation tracking.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_hash: Option<ContentHash>,
}

impl Layer {
    /// Create a new layer.
    pub fn new(kind: LayerKind, hash: ContentHash, size: u64) -> Self {
        Self {
            kind,
            hash,
            size,
            generated_locally: true,
            modified_at: current_timestamp(),
            parent_hash: None,
        }
    }

    /// Create a layer with parent tracking.
    pub fn with_parent(mut self, parent_hash: ContentHash) -> Self {
        self.parent_hash = Some(parent_hash);
        self
    }

    /// Mark as received from peer (not locally generated).
    pub fn as_received(mut self) -> Self {
        self.generated_locally = false;
        self
    }

    /// Check if this layer needs to be shipped (vs. regenerated by peer).
    #[inline]
    pub fn should_ship(&self, peer_can_generate: bool) -> bool {
        match self.kind {
            LayerKind::Canonical => true,  // Always ship canonical data
            LayerKind::IndexMeta => true,  // Always ship metadata (small)
            _ => !peer_can_generate,       // Ship if peer can't generate
        }
    }

    /// Check if this layer is stale relative to a parent hash.
    #[inline]
    pub fn is_stale(&self, current_parent_hash: &ContentHash) -> bool {
        match &self.parent_hash {
            Some(h) => h != current_parent_hash,
            None => false, // No parent tracking, assume not stale
        }
    }
}

/// A set of layers representing complete sync state.
/// 
/// Uses a fixed-size array for cache-friendly access.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LayerSet {
    /// L0: Canonical data.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonical: Option<Layer>,

    /// L1: Embeddings.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedding: Option<Layer>,

    /// L2a: Index metadata.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_meta: Option<Layer>,

    /// L2b: Index data.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_data: Option<Layer>,
}

impl LayerSet {
    /// Create a new empty layer set.
    #[inline]
    pub const fn new() -> Self {
        Self {
            canonical: None,
            embedding: None,
            index_meta: None,
            index_data: None,
        }
    }

    /// Add or update a layer.
    pub fn set_layer(&mut self, layer: Layer) {
        match layer.kind {
            LayerKind::Canonical => self.canonical = Some(layer),
            LayerKind::Embedding => self.embedding = Some(layer),
            LayerKind::IndexMeta => self.index_meta = Some(layer),
            LayerKind::IndexData => self.index_data = Some(layer),
        }
    }

    /// Get a layer by kind.
    #[inline]
    pub fn get(&self, kind: LayerKind) -> Option<&Layer> {
        match kind {
            LayerKind::Canonical => self.canonical.as_ref(),
            LayerKind::Embedding => self.embedding.as_ref(),
            LayerKind::IndexMeta => self.index_meta.as_ref(),
            LayerKind::IndexData => self.index_data.as_ref(),
        }
    }

    /// Get a mutable reference to a layer by kind.
    #[inline]
    pub fn get_mut(&mut self, kind: LayerKind) -> Option<&mut Layer> {
        match kind {
            LayerKind::Canonical => self.canonical.as_mut(),
            LayerKind::Embedding => self.embedding.as_mut(),
            LayerKind::IndexMeta => self.index_meta.as_mut(),
            LayerKind::IndexData => self.index_data.as_mut(),
        }
    }

    /// Remove a layer.
    pub fn remove(&mut self, kind: LayerKind) -> Option<Layer> {
        match kind {
            LayerKind::Canonical => self.canonical.take(),
            LayerKind::Embedding => self.embedding.take(),
            LayerKind::IndexMeta => self.index_meta.take(),
            LayerKind::IndexData => self.index_data.take(),
        }
    }

    /// Check if a layer has changed compared to another set.
    #[inline]
    pub fn layer_changed(&self, kind: LayerKind, other: &LayerSet) -> bool {
        match (self.get(kind), other.get(kind)) {
            (Some(a), Some(b)) => a.hash != b.hash,
            (Some(_), None) | (None, Some(_)) => true,
            (None, None) => false,
        }
    }

    /// Get total size of all layers.
    pub fn total_size(&self) -> u64 {
        self.iter().map(|l| l.size).sum()
    }

    /// Count present layers.
    pub fn count(&self) -> usize {
        self.iter().count()
    }

    /// Iterate over present layers.
    pub fn iter(&self) -> impl Iterator<Item = &Layer> {
        [
            self.canonical.as_ref(),
            self.embedding.as_ref(),
            self.index_meta.as_ref(),
            self.index_data.as_ref(),
        ]
        .into_iter()
        .flatten()
    }

    /// Get layers that are stale and need regeneration.
    pub fn stale_layers(&self) -> Vec<LayerKind> {
        let mut stale = Vec::new();

        // Check if embedding is stale relative to canonical
        if let (Some(canonical), Some(embedding)) = (&self.canonical, &self.embedding) {
            if embedding.is_stale(&canonical.hash) {
                stale.push(LayerKind::Embedding);
            }
        }

        // Check if index is stale relative to embedding
        if let (Some(embedding), Some(index)) = (&self.embedding, &self.index_data) {
            if index.is_stale(&embedding.hash) {
                stale.push(LayerKind::IndexData);
            }
        }

        stale
    }

    /// Compute a delta between this set and another.
    /// Returns layers that exist in self but are different/missing in other.
    pub fn diff(&self, other: &LayerSet) -> LayerDiff {
        let mut added = Vec::new();
        let mut modified = Vec::new();
        let mut removed = Vec::new();

        for kind in LayerKind::ALL {
            match (self.get(kind), other.get(kind)) {
                (Some(_), None) => added.push(kind),
                (None, Some(_)) => removed.push(kind),
                (Some(a), Some(b)) if a.hash != b.hash => modified.push(kind),
                _ => {}
            }
        }

        LayerDiff {
            added,
            modified,
            removed,
        }
    }
}

/// Difference between two layer sets.
#[derive(Debug, Clone, Default)]
pub struct LayerDiff {
    /// Layers present in first set but not second.
    pub added: Vec<LayerKind>,
    /// Layers present in both but with different hashes.
    pub modified: Vec<LayerKind>,
    /// Layers present in second set but not first.
    pub removed: Vec<LayerKind>,
}

impl LayerDiff {
    /// Check if there are any differences.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.added.is_empty() && self.modified.is_empty() && self.removed.is_empty()
    }

    /// Get all layers that need to be synced (added or modified).
    pub fn needs_sync(&self) -> impl Iterator<Item = LayerKind> + '_ {
        self.added.iter().chain(self.modified.iter()).copied()
    }
}

/// Get current Unix timestamp.
#[inline]
fn current_timestamp() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_secs())
        .unwrap_or(0)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::sync::hash_content;

    #[test]
    fn test_layer_kind_levels() {
        assert_eq!(LayerKind::Canonical.level(), 0);
        assert_eq!(LayerKind::Embedding.level(), 1);
        assert_eq!(LayerKind::IndexMeta.level(), 2);
        assert_eq!(LayerKind::IndexData.level(), 2);
    }

    #[test]
    fn test_layer_kind_parents() {
        assert_eq!(LayerKind::Canonical.parent(), None);
        assert_eq!(LayerKind::Embedding.parent(), Some(LayerKind::Canonical));
        assert_eq!(LayerKind::IndexData.parent(), Some(LayerKind::Embedding));
    }

    #[test]
    fn test_layer_kind_canonical() {
        assert!(LayerKind::Canonical.is_canonical());
        assert!(!LayerKind::Embedding.is_canonical());
    }

    #[test]
    fn test_layer_kind_derived() {
        assert!(!LayerKind::Canonical.is_derived());
        assert!(LayerKind::Embedding.is_derived());
        assert!(LayerKind::IndexData.is_derived());
    }

    #[test]
    fn test_layer_should_ship() {
        let hash = hash_content(b"test");
        let canonical = Layer::new(LayerKind::Canonical, hash, 100);
        let embedding = Layer::new(LayerKind::Embedding, hash, 200);

        // Canonical always ships
        assert!(canonical.should_ship(true));
        assert!(canonical.should_ship(false));

        // Embedding ships only if peer can't generate
        assert!(!embedding.should_ship(true));
        assert!(embedding.should_ship(false));
    }

    #[test]
    fn test_layer_staleness() {
        let parent_hash = hash_content(b"parent");
        let new_parent_hash = hash_content(b"new_parent");

        let layer = Layer::new(LayerKind::Embedding, hash_content(b"test"), 100)
            .with_parent(parent_hash);

        assert!(!layer.is_stale(&parent_hash));
        assert!(layer.is_stale(&new_parent_hash));
    }

    #[test]
    fn test_layer_set_operations() {
        let mut set = LayerSet::new();
        let hash = hash_content(b"test");

        let layer = Layer::new(LayerKind::Canonical, hash, 100);
        set.set_layer(layer);

        assert!(set.get(LayerKind::Canonical).is_some());
        assert!(set.get(LayerKind::Embedding).is_none());
        assert_eq!(set.total_size(), 100);
        assert_eq!(set.count(), 1);
    }

    #[test]
    fn test_layer_changed_detection() {
        let mut set1 = LayerSet::new();
        let mut set2 = LayerSet::new();

        let hash1 = hash_content(b"content1");
        let hash2 = hash_content(b"content2");

        set1.set_layer(Layer::new(LayerKind::Canonical, hash1, 100));
        set2.set_layer(Layer::new(LayerKind::Canonical, hash2, 100));

        assert!(set1.layer_changed(LayerKind::Canonical, &set2));
        assert!(!set1.layer_changed(LayerKind::Embedding, &set2)); // Both None
    }

    #[test]
    fn test_layer_diff() {
        let mut set1 = LayerSet::new();
        let mut set2 = LayerSet::new();

        set1.set_layer(Layer::new(LayerKind::Canonical, hash_content(b"a"), 100));
        set1.set_layer(Layer::new(LayerKind::Embedding, hash_content(b"b"), 200));

        set2.set_layer(Layer::new(LayerKind::Canonical, hash_content(b"c"), 100));

        let diff = set1.diff(&set2);
        assert_eq!(diff.added, vec![LayerKind::Embedding]);
        assert_eq!(diff.modified, vec![LayerKind::Canonical]);
        assert!(diff.removed.is_empty());
    }

    #[test]
    fn test_stale_layers() {
        let mut set = LayerSet::new();

        let canonical_hash = hash_content(b"canonical");
        let old_canonical_hash = hash_content(b"old");

        set.set_layer(Layer::new(LayerKind::Canonical, canonical_hash, 100));
        set.set_layer(
            Layer::new(LayerKind::Embedding, hash_content(b"emb"), 200)
                .with_parent(old_canonical_hash),
        );

        let stale = set.stale_layers();
        assert_eq!(stale, vec![LayerKind::Embedding]);
    }

    #[test]
    fn test_layer_serde() {
        let layer = Layer::new(LayerKind::Canonical, hash_content(b"test"), 100);
        let json = serde_json::to_string(&layer).unwrap();
        let parsed: Layer = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.kind, LayerKind::Canonical);
        assert_eq!(parsed.hash, layer.hash);
    }
}
